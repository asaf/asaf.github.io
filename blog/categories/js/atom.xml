<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: js | Asaf Shakarchi]]></title>
  <link href="http://asaf.github.io/blog/categories/js/atom.xml" rel="self"/>
  <link href="http://asaf.github.io/"/>
  <updated>2015-09-14T15:34:39+03:00</updated>
  <id>http://asaf.github.io/</id>
  <author>
    <name><![CDATA[Asaf Shakarchi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Default function options stash with ES6 destructuring assignment.]]></title>
    <link href="http://asaf.github.io/blog/2015/09/14/js-default-function-options-stash-with-es6/"/>
    <updated>2015-09-14T15:28:00+03:00</updated>
    <id>http://asaf.github.io/blog/2015/09/14/js-default-function-options-stash-with-es6</id>
    <content type="html"><![CDATA[<p>ES6 opens up a clean approach to define function options stash thanks to the destructuring assignment syntax,</p>

<p>Assuming we want options but let the user overrides it, we can declare our function that way:</p>

<p>function hello(param1, {debug = true, whatever = false} = {}) {
}</p>

<p>The advantages are, clearly there is no code in the body function to achieve default options &amp; user overrides.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add additional properties to a result of a function or a fucntion map using ES6 spread operator.]]></title>
    <link href="http://asaf.github.io/blog/2015/09/13/add-additional-properties-to-a-result-of-a-function-or-a-fucntion-map-using-es6-spread-operator/"/>
    <updated>2015-09-13T15:08:00+03:00</updated>
    <id>http://asaf.github.io/blog/2015/09/13/add-additional-properties-to-a-result-of-a-function-or-a-fucntion-map-using-es6-spread-operator</id>
    <content type="html"><![CDATA[<p>Sometimes it makes sense to add additional properties to a result of a function,</p>

<p>Examples could be enhancing an operation result with some meta data, extending with a timestamp, run time, etc,</p>

<p>Using ES6, we could easily achieve this by:</p>

<p>```js
bindData(oper, props) {
  if (typeof oper === &lsquo;function&rsquo;) {</p>

<pre><code>return (...args) =&gt; ({
  ...oper(...args),
  ...props
});
</code></pre>

<p>  }
  if (typeof oper === &lsquo;object&rsquo;) {</p>

<pre><code>return Object.keys(oper).reduce((prev, key) =&gt; ({
  ...prev,
  [key]: bindData(oper[key], props)
}), {});
</code></pre>

<p>  }
  return oper;
}
```</p>

<p>Here are some clarifications:</p>

<ol>
<li>If <code>oper</code> is a function, we decorate the original function by a closure,
<code>return (...args)</code> is the closure (read more about the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread</a> operator.</li>
</ol>


<p>In general, <code>myFunction(...args);</code> is equelevent to <code>(args) { oper.apply(null, args); }</code>,</p>

<ol>
<li>When the returned function is invoked, the result of the original function <code>...oper(...args)</code> is then merged with the <code>props</code> object, in other words:</li>
</ol>


<p><code>...oper(), ...props</code> is equelevent to: <code>Object.assign({}, oper(), props);</code>
Read more about <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a></p>

<ol>
<li>If <code>oper</code> is an object, we bind each of its key&rsquo;s recursively (assuming each property is a function).</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ES6, React & Browserify]]></title>
    <link href="http://asaf.github.io/blog/2015/09/05/react/"/>
    <updated>2015-09-05T19:20:00+03:00</updated>
    <id>http://asaf.github.io/blog/2015/09/05/react</id>
    <content type="html"><![CDATA[<h2>ES6, React &amp; Browserify</h2>

<p><a href="http://browserify.org/">Browserify</a> is a <em>lightweight</em> build tool for JS, you can start <em>&lsquo;require&rsquo;</em> modules with zero configuration,
Thanks to <a href="https://github.com/babel/babelify">Babelify</a>, you can start writing ES6 code (via <a href="babeljs.io">Babel</a>) write away,</p>

<p>Here&rsquo;s a proof how simple it is,</p>

<p>Lets create a <code>package.json</code> file and install minimal dependencies</p>

<p><code>bash
npm init
npm install --save react
npm install --save-dev browserify babelify watchify
</code></p>

<p>Lets give Browserify a hint that it should perform code transformation via <code>babelify</code> by adding this json tag to <code>package.json</code></p>

<p>```js
&ldquo;browserify&rdquo;: {
  &ldquo;transform&rdquo;: [</p>

<pre><code>"babelify"
</code></pre>

<p>  ]
}
```</p>

<p>It can also be nice to just type <code>npm start</code> when developing, so lets add a <code>start</code> script to <code>package.json</code> as well</p>

<p>&ldquo;start&rdquo;: &ldquo;watchify &mdash;extension=js -o bundle.js index.js &amp; python -m SimpleHTTPServer&rdquo;,</p>

<p>Note: Watchify is not mandatory but it&rsquo;s great tool for watching your code changes and auto rebuild when a change gets discovered.</p>

<p>Lets put the simplest index file ever:</p>

<p>```html
<html>
  <body></p>

<pre><code>&lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Here&rsquo;s a simple ES6 class with React.</p>

<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>class Hello extends React.Component {
  constructor(props) {</p>

<pre><code>super(props)
this.state = {count: props.initCount}
this.tick = this.tick.bind(this)
</code></pre>

<p>  }</p>

<p>  tick () {</p>

<pre><code>this.setState({count: this.state.count + 1});
</code></pre>

<p>  }
  render(){</p>

<pre><code>let { name } = this.props
let { count } = this.state
return (
  &lt;button onClick={this.tick}&gt;Hello {name} {count}&lt;/button&gt;
);
</code></pre>

<p>  }
}</p>

<p>React.render(<Hello name="Stranger" initCount={5}/>, document.body)</p>

<p>```</p>

<h2>Running the code:</h2>

<p><code>bash
npm start
</code></p>

<p>Open browser <a href="http://localhost:8000">http://localhost:8000</a></p>

<p>To summary:</p>

<p>1) Browserify is lightweight build tool, it handles modularity by understanding <code>require</code>
2) Labelify is a plugin for Browserify, it takes care of transpilling ES6 code to ES5 via Babel.
3) Thanks to Babel &amp; React integration, there&rsquo;s no need for any extra plugins to perform JSX transformations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extending behavior of React Components by ES6 Decorators & Higher Order Components]]></title>
    <link href="http://asaf.github.io/blog/2015/06/23/extending-behavior-of-react-components-by-es6-decorators/"/>
    <updated>2015-06-23T18:04:00+03:00</updated>
    <id>http://asaf.github.io/blog/2015/06/23/extending-behavior-of-react-components-by-es6-decorators</id>
    <content type="html"><![CDATA[<h2>About Mixins &amp; Higher Order Components</h2>

<p>Sometimes it makes sense to extends a behavior of a component, while <a href="https://facebook.github.io/react/docs/reusable-components.html#mixins">mixins</a> are still alive, they'r <a href="https://twitter.com/sebmarkbage/status/571389309586051072">not recommended</a> anylonger, use <a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750">Higher Order Components</a> instead.</p>

<p>So instead of doing this:</p>

<p>```js
function StoreMixin(&hellip;stores) {
  var Mixin = {</p>

<pre><code>getInitialState() {
  return this.getStateFromStores(this.props);
},
...
</code></pre>

<p>  }
}</p>

<p>var UserProfilePage = React.createClass({
  mixins: [StoreMixin(UserStore)],
  propTypes: {</p>

<pre><code>userId: PropTypes.number.isRequired
</code></pre>

<p>  },
  &hellip;
})
```</p>

<p>You can do that:</p>

<p>```js
function connectToStores(Component, stores, getStateFromStores) {
  const StoreConnection = React.createClass({</p>

<pre><code>getInitialState() {
  return getStateFromStores(this.props);
},
...
render() {
  return &lt;Component {...this.props} {...this.state} /&gt;;
}
</code></pre>

<p>  })
}
```</p>

<p>We just wrap the component and passes some additional props to it, it is a clean and generic solution for extending
components without merging behaviors being implemented by React&rsquo;s mixin merge logic.</p>

<p>You can read more about <em>Higher Order Components</em> <a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750">here</a></p>

<h2>Extending via ES6 Decorators</h2>

<p>Sometimes it makes sense to extends a component without the need to wrap it manually, this technique is common in different <a href="https://github.com/gaearon/redux/blob/master/src/components/createConnectDecorator.js">frameworks</a> to define components less verbosely when extra functionality is demanded.</p>

<p>Here is a short example how it works,
Lets extends the <a href="https://www.tildedave.com/2014/11/15/introduction-to-contexts-in-react-js.html">context</a> of our component hierarchy with a <code>print</code> function, so we use it in our <code>render</code> method:</p>

<p>```js
class MyPage extends Component {</p>

<pre><code>static contextTypes = contextTypes;
render() {
    return(
        &lt;div&gt;{this.context.print('Hello World')}&lt;/div&gt;
    )
}
</code></pre>

<p>}
```</p>

<p>Assuming <code>MyPage</code> is a child component of <code>App</code>, here is how our <code>App</code> component looks like:</p>

<p>```js
var contextTypes = {</p>

<pre><code>print: PropTypes.func.isRequired
</code></pre>

<p>}</p>

<p>var myContext = {</p>

<pre><code>print: (m) =&gt; (m)
</code></pre>

<p>}</p>

<p>@context(contextTypes, myContext)
export default class App extends Component {</p>

<pre><code>render() {
    return (
        &lt;MyPage/&gt;
    )
}
</code></pre>

<p>}
```</p>

<p>And here is the code of the <em>decorator</em>:</p>

<p>```js
export default function context(contextTypes, context) {</p>

<pre><code>return function (DecoratedComponent) {
    return class {
        static childContextTypes = contextTypes;
        getChildContext() {
          return context;
        }
        render() {
          return (
            &lt;DecoratedComponent {...this.props} /&gt;
          );
        }
    }
}
</code></pre>

<p>}
```</p>

<p>The <em>Decorator</em> expects an expression and invokes the function with the given parameters and must return a function that expects the annotated component as a parameter, then we just return a <code>class</code> with some context the <em>wraps</em> our component.</p>

<p>You can read more about <a href="https://github.com/wycats/javascript-decorators">Decorators</a> here.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elegant way to use React with ES6/ES7 features.]]></title>
    <link href="http://asaf.github.io/blog/2015/06/19/elegant-way-to-use-react-with-es6-slash-es7-features/"/>
    <updated>2015-06-19T01:51:00+03:00</updated>
    <id>http://asaf.github.io/blog/2015/06/19/elegant-way-to-use-react-with-es6-slash-es7-features</id>
    <content type="html"><![CDATA[<h2>React, JSX, ES6.</h2>

<p>So you want React, JSX the markup and write ES6/7 code style, but setting a working
environment may be pain in the ass,</p>

<p>More to say, Facebook announced that its JSTransformer and react-tools going to be <a href="https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html">deprecated</a>,</p>

<p>It seems like it&rsquo;s starting to get confusing how to set a full working environment
with JSX transformation and ES6/ES7 support.</p>

<p>While React 0.13.0-beta-1 announced great support for ES6, it still unclear how
to build a full working environment that supports ES6 either,</p>

<p>You can find multiple boilerplate projects at <a href="http://www.github.com">github</a> using
WebPack, Browserify and other module loader tools available nowadays but I found all
of them unclean, full of build scripts and things that just make things more complicated,</p>

<p>After doing some research, I feel like the best approach would be to go with <a href="http://jspm.io/">JSPM</a> repository that is based on <a href="https://github.com/systemjs/systemjs">SystemJs</a> dynamic module loader.</p>

<p>The chosen tools:</p>

<ol>
<li>SytemJs &ndash; It is a Universal dynamic module loader, it supports AMD, CommonJS
but the best of it is its native support for ES6 modules, with native support for
Babel as its transpiler to ES5, it also uses <a href="http://jspm.io">JSPM</a> which supports
NPM and Github repos such as Bower does, so you can enjoy packages from both worlds.</li>
<li><a href="https://babeljs.io">Babel</a> as the ES6 transpiler, this transpiler is responsible
to translate ES6 coding to ES5 as ES6 is not supported yet by most browsers, Babel is
also supported by Facebook and provides JSX native transformation.</li>
</ol>


<p>Enough said, here&rsquo;s some code, we&rsquo;ll start with empty folder!</p>

<h2>Setting a clean working environment</h2>

<h3>Pre requisites</h3>

<p>Lets install pre requisites:</p>

<p><code>bash
npm install -g jspm
npm install -g http-server
</code></p>

<h3>Initializing Project</h3>

<p>Create an empty folder and run</p>

<p><code>bash
jspm init
</code></p>

<p>You can choose default answers for all questions if not sure,</p>

<p>This will create a <code>package.json</code> and a <code>config.js</code> file required for SystemJs
to work properly.</p>

<p>Now lets tweak <code>config.js</code> a bit to support ES7 so you can enjoy ES7+ property
initializers and other ES7 cool features</p>

<p>``` javascript
&ldquo;babelOptions&rdquo;: {
  blacklist: [],
  stage: 0,
  &ldquo;optional&rdquo;: [</p>

<pre><code>"runtime"
</code></pre>

<p>  ]
},
```</p>

<p><code>blacklist: []</code> tells Babel not to ignore JSX transformation as by default it&rsquo;s disabled,
<code>stage: 0</code> tells Babel that we want to use experimental ES7 syntax.</p>

<h3>Creating an index.html file</h3>

<p>Lets create our index file as every web app that respect itself has one!</p>

<p>Simply create <code>index.html</code> in the root folder with your favorite editor</p>

<p>```javascript
&lt;!DOCTYPE html>
<html></p>

<pre><code>&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Title Here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- build:js --&gt;
    &lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt;
    &lt;script src="config.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        System.import('app/main');
    &lt;/script&gt;
    &lt;!-- endbuild --&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>See how clean and elegant is it? we just load <code>system.js</code> as our dynamic module loader
and the generated <code>config.js</code> that holds our <code>SystemJs</code> configuration.</p>

<p>Then we import <code>app/main</code> as our first ES6 module that serves the application.</p>

<h3>Create a simple React based class.</h3>

<p>Thanks to SystemJs, we can now fully write application modules, lets create our
<code>main</code> application entry point</p>

<p>Create a file <code>app/main.js</code> with the following content:</p>

<p>``` javascript
import React from &lsquo;react&rsquo;;
import App from &lsquo;./app&rsquo;;</p>

<p>React.render(<App/>, document.body);
```</p>

<p>This just import <code>React</code> and renders our <code>App</code> component.</p>

<p>Her eis the <code>app/app.js</code> file content:</p>

<p>``` javascript
import React from &lsquo;react&rsquo;;
var {Component} = React;</p>

<p>export default class MyApp extends Component {</p>

<pre><code>static propTypes = {
   flux: React.PropTypes.object.isRequired
</code></pre>

<p>   }</p>

<pre><code>render () {
    return (
        &lt;div&gt;Hello&lt;/div&gt;
    )
}
</code></pre>

<p>}
```</p>

<p>Now run <code>http-server</code> in your folder,</p>

<p>hitting <a href="http://localhost:8080">http://localhost:8080</a> should display <em>Hello</em> :)</p>

<h2>Summary</h2>

<p>The combination of React, JSX transformation via Babel, and ES6/7 support via
SystemJS provides a great clean and elegant way to write React code without the
overhead of build systems and ugly scripts around.</p>
]]></content>
  </entry>
  
</feed>
