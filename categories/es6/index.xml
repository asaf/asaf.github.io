<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es6 on Asaf Shakarchi</title>
    <link>http://asaf.github.io/categories/es6/</link>
    <description>Recent content in Es6 on Asaf Shakarchi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Sep 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://asaf.github.io/categories/es6/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Default function options stash with ES6 destructuring assignment.</title>
      <link>http://asaf.github.io/2015/09/14/js-default-function-options-stash-with-es6/</link>
      <pubDate>Mon, 14 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://asaf.github.io/2015/09/14/js-default-function-options-stash-with-es6/</guid>
      <description>&lt;p&gt;ES6 opens up a clean approach to define function options stash thanks to the destructuring assignment syntax,&lt;/p&gt;

&lt;p&gt;Assuming we want options but let the user overrides it, we can declare our function that way:&lt;/p&gt;

&lt;p&gt;function hello(param1, {debug = true, whatever = false} = {}) {
}&lt;/p&gt;

&lt;p&gt;The advantages are, clearly there is no code in the body function to achieve default options &amp;amp; user overrides.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Add additional properties to a result of a function or a fucntion map using ES6 spread operator.</title>
      <link>http://asaf.github.io/2015/09/13/add-additional-properties-to-a-result-of-a-function-or-a-fucntion-map-using-es6-spread-operator/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://asaf.github.io/2015/09/13/add-additional-properties-to-a-result-of-a-function-or-a-fucntion-map-using-es6-spread-operator/</guid>
      <description>&lt;p&gt;Sometimes it makes sense to add additional properties to a result of a function,&lt;/p&gt;

&lt;p&gt;Examples could be enhancing an operation result with some meta data, extending with a timestamp, run time, etc,&lt;/p&gt;

&lt;p&gt;Using ES6, we could easily achieve this by:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;bindData(oper, props) {
  if (typeof oper === &#39;function&#39;) {
    return (...args) =&amp;gt; ({
      ...oper(...args),
      ...props
    });
  }
  if (typeof oper === &#39;object&#39;) {
    return Object.keys(oper).reduce((prev, key) =&amp;gt; ({
      ...prev,
      [key]: bindData(oper[key], props)
    }), {});
  }
  return oper;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are some clarifications:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;oper&lt;/code&gt; is a function, we decorate the original function by a closure,
&lt;code&gt;return (...args)&lt;/code&gt; is the closure (read more about the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&#34;&gt;spread&lt;/a&gt; operator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In general, &lt;code&gt;myFunction(...args);&lt;/code&gt; is equelevent to &lt;code&gt;(args) { oper.apply(null, args); }&lt;/code&gt;,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;When the returned function is invoked, the result of the original function &lt;code&gt;...oper(...args)&lt;/code&gt; is then merged with the &lt;code&gt;props&lt;/code&gt; object, in other words:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;...oper(), ...props&lt;/code&gt; is equelevent to: &lt;code&gt;Object.assign({}, oper(), props);&lt;/code&gt;
Read more about &lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&#34;&gt;Object.assign&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;oper&lt;/code&gt; is an object, we bind each of its key&amp;rsquo;s recursively (assuming each property is a function).&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ES6, React &amp; Browserify</title>
      <link>http://asaf.github.io/2015/09/05/react/</link>
      <pubDate>Sat, 05 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://asaf.github.io/2015/09/05/react/</guid>
      <description>

&lt;h2 id=&#34;es6-react-browserify&#34;&gt;ES6, React &amp;amp; Browserify&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://browserify.org/&#34;&gt;Browserify&lt;/a&gt; is a &lt;em&gt;lightweight&lt;/em&gt; build tool for JS, you can start &lt;em&gt;&amp;lsquo;require&amp;rsquo;&lt;/em&gt; modules with zero configuration,
Thanks to &lt;a href=&#34;https://github.com/babel/babelify&#34;&gt;Babelify&lt;/a&gt;, you can start writing ES6 code (via &lt;a href=&#34;babeljs.io&#34;&gt;Babel&lt;/a&gt;) write away,&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a proof how simple it is,&lt;/p&gt;

&lt;p&gt;Lets create a &lt;code&gt;package.json&lt;/code&gt; file and install minimal dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm init
npm install --save react
npm install --save-dev browserify babelify watchify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets give Browserify a hint that it should perform code transformation via &lt;code&gt;babelify&lt;/code&gt; by adding this json tag to &lt;code&gt;package.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;quot;browserify&amp;quot;: {
  &amp;quot;transform&amp;quot;: [
    &amp;quot;babelify&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can also be nice to just type &lt;code&gt;npm start&lt;/code&gt; when developing, so lets add a &lt;code&gt;start&lt;/code&gt; script to &lt;code&gt;package.json&lt;/code&gt; as well&lt;/p&gt;

&lt;p&gt;&amp;ldquo;start&amp;rdquo;: &amp;ldquo;watchify &amp;ndash;extension=js -o bundle.js index.js &amp;amp; python -m SimpleHTTPServer&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;Note: Watchify is not mandatory but it&amp;rsquo;s great tool for watching your code changes and auto rebuild when a change gets discovered.&lt;/p&gt;

&lt;p&gt;Lets put the simplest index file ever:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a simple ES6 class with React.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React from &#39;react&#39;;

class Hello extends React.Component {
  constructor(props) {
    super(props)
    this.state = {count: props.initCount}
    this.tick = this.tick.bind(this)
  }

  tick () {
    this.setState({count: this.state.count + 1});
  }
  render(){
    let { name } = this.props
    let { count } = this.state
    return (
      &amp;lt;button onClick={this.tick}&amp;gt;Hello {name} {count}&amp;lt;/button&amp;gt;
    );
  }
}

React.render(&amp;lt;Hello name=&amp;quot;Stranger&amp;quot; initCount={5}/&amp;gt;, document.body)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-the-code&#34;&gt;Running the code:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open browser &lt;a href=&#34;http://localhost:8000&#34;&gt;http://localhost:8000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To summary:&lt;/p&gt;

&lt;p&gt;1) Browserify is lightweight build tool, it handles modularity by understanding &lt;code&gt;require&lt;/code&gt;
2) Labelify is a plugin for Browserify, it takes care of transpilling ES6 code to ES5 via Babel.
3) Thanks to Babel &amp;amp; React integration, there&amp;rsquo;s no need for any extra plugins to perform JSX transformations.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Extending behavior of React Components by ES6 Decorators &amp; Higher Order Components</title>
      <link>http://asaf.github.io/2015/06/23/extending-behavior-of-react-components-by-es6-decorators/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://asaf.github.io/2015/06/23/extending-behavior-of-react-components-by-es6-decorators/</guid>
      <description>

&lt;h2 id=&#34;about-mixins-higher-order-components&#34;&gt;About Mixins &amp;amp; Higher Order Components&lt;/h2&gt;

&lt;p&gt;Sometimes it makes sense to extends a behavior of a component, while &lt;a href=&#34;https://facebook.github.io/react/docs/reusable-components.html#mixins&#34;&gt;mixins&lt;/a&gt; are still alive, they&amp;rsquo;r &lt;a href=&#34;https://twitter.com/sebmarkbage/status/571389309586051072&#34;&gt;not recommended&lt;/a&gt; anylonger, use &lt;a href=&#34;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&#34;&gt;Higher Order Components&lt;/a&gt; instead.&lt;/p&gt;

&lt;p&gt;So instead of doing this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function StoreMixin(...stores) {
  var Mixin = {
    getInitialState() {
      return this.getStateFromStores(this.props);
    },
    ...
  }
}

var UserProfilePage = React.createClass({
  mixins: [StoreMixin(UserStore)],
  propTypes: {
    userId: PropTypes.number.isRequired
  },
  ...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can do that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function connectToStores(Component, stores, getStateFromStores) {
  const StoreConnection = React.createClass({
    getInitialState() {
      return getStateFromStores(this.props);
    },
    ...
    render() {
      return &amp;lt;Component {...this.props} {...this.state} /&amp;gt;;
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We just wrap the component and passes some additional props to it, it is a clean and generic solution for extending
components without merging behaviors being implemented by React&amp;rsquo;s mixin merge logic.&lt;/p&gt;

&lt;p&gt;You can read more about &lt;em&gt;Higher Order Components&lt;/em&gt; &lt;a href=&#34;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;extending-via-es6-decorators&#34;&gt;Extending via ES6 Decorators&lt;/h2&gt;

&lt;p&gt;Sometimes it makes sense to extends a component without the need to wrap it manually, this technique is common in different &lt;a href=&#34;https://github.com/gaearon/redux/blob/master/src/components/createConnectDecorator.js&#34;&gt;frameworks&lt;/a&gt; to define components less verbosely when extra functionality is demanded.&lt;/p&gt;

&lt;p&gt;Here is a short example how it works,
Lets extends the &lt;a href=&#34;https://www.tildedave.com/2014/11/15/introduction-to-contexts-in-react-js.html&#34;&gt;context&lt;/a&gt; of our component hierarchy with a &lt;code&gt;print&lt;/code&gt; function, so we use it in our &lt;code&gt;render&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyPage extends Component {
    static contextTypes = contextTypes;
    render() {
        return(
            &amp;lt;div&amp;gt;{this.context.print(&#39;Hello World&#39;)}&amp;lt;/div&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming &lt;code&gt;MyPage&lt;/code&gt; is a child component of &lt;code&gt;App&lt;/code&gt;, here is how our &lt;code&gt;App&lt;/code&gt; component looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var contextTypes = {
    print: PropTypes.func.isRequired
}

var myContext = {
    print: (m) =&amp;gt; (m)
}

@context(contextTypes, myContext)
export default class App extends Component {
    render() {
        return (
            &amp;lt;MyPage/&amp;gt;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is the code of the &lt;em&gt;decorator&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;export default function context(contextTypes, context) {

    return function (DecoratedComponent) {
        return class {
            static childContextTypes = contextTypes;
            getChildContext() {
              return context;
            }
            render() {
              return (
                &amp;lt;DecoratedComponent {...this.props} /&amp;gt;
              );
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;Decorator&lt;/em&gt; expects an expression and invokes the function with the given parameters and must return a function that expects the annotated component as a parameter, then we just return a &lt;code&gt;class&lt;/code&gt; with some context the &lt;em&gt;wraps&lt;/em&gt; our component.&lt;/p&gt;

&lt;p&gt;You can read more about &lt;a href=&#34;https://github.com/wycats/javascript-decorators&#34;&gt;Decorators&lt;/a&gt; here.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>